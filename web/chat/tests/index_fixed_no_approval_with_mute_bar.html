<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HereNow — Chat</title>
  <meta name="description" content="Consent-first, ephemeral chat. Explicit opt-in per session. Close tab = chat off." />
  <meta name="referrer" content="no-referrer" />
  <style>
    :root{
      --bg:#0b1020; --panel:#0f1730; --text:#e9ecff; --muted:#b7c0ff; --faint:#7f8ad6;
      --line:rgba(233,236,255,.15); --good:#47e6b1; --warn:#ffcc66; --bad:#ff6b6b; --link:#78a6ff;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      background: radial-gradient(1200px 700px at 20% 10%, rgba(120,166,255,.15), transparent 60%),
                  radial-gradient(1000px 650px at 80% 20%, rgba(71,230,177,.10), transparent 55%),
                  var(--bg);
      color:var(--text);
      line-height:1.5;
    }
    a{color:var(--link); text-decoration:none}
    a:hover{text-decoration:underline}
    .wrap{max-width:980px; margin:0 auto; padding:28px 18px 64px}
    header{
      display:flex; gap:16px; align-items:flex-start; justify-content:space-between; flex-wrap:wrap;
      padding:18px 18px 16px; background:rgba(15,23,48,.72); border:1px solid var(--line);
      border-radius:14px; backdrop-filter:blur(8px);
    }
    h1{margin:0; font-size:20px}
    header p{margin:6px 0 0; color:var(--muted); max-width:75ch}
    .btn{
      display:inline-block; padding:10px 14px; border-radius:12px; border:1px solid var(--line);
      background:rgba(255,255,255,.04); color:var(--text); font-weight:700; cursor:pointer;
    }
    .btn:hover{background:rgba(255,255,255,.06)}
    .btn.primary{border-color:rgba(71,230,177,.35); background:rgba(71,230,177,.10)}
    .btn.primary:hover{background:rgba(71,230,177,.16)}
    .btn.danger{border-color:rgba(255,107,107,.35); background:rgba(255,107,107,.10)}
    .btn.danger:hover{background:rgba(255,107,107,.16)}
    .btn:disabled{opacity:.55; cursor:not-allowed}
    main{margin-top:16px}
    .grid{display:grid; grid-template-columns: 1fr; gap:14px}
    section{
      padding:18px 18px 16px; background:rgba(15,23,48,.58); border:1px solid var(--line);
      border-radius:14px;
    }
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .muted{color:var(--muted)}
    .faint{color:var(--faint)}
.toast {
  display:inline-block;
  padding:6px 10px;
  border-radius:999px;
  border:1px solid rgba(233,236,255,.16);
  background:rgba(0,0,0,.25);
  font-weight:700;
  font-size:12px;
}
.toast.good { border-color:rgba(71,230,177,.35); color:var(--good); }
.toast.bad  { border-color:rgba(255,107,107,.35); color:var(--bad); }

    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:999px; border:1px solid var(--line);
      background:rgba(255,255,255,.03); font-weight:700;
    }
    .dot{width:10px; height:10px; border-radius:999px; background:var(--warn); box-shadow:0 0 0 3px rgba(255,204,102,.10)}
    .dot.good{background:var(--good); box-shadow:0 0 0 3px rgba(71,230,177,.10)}
    .dot.bad{background:var(--bad); box-shadow:0 0 0 3px rgba(255,107,107,.10)}
    .box{
      padding:12px; border-radius:12px; border:1px solid rgba(233,236,255,.12);
      background:rgba(0,0,0,.20);
    }
    textarea{
      width:100%; min-height:150px; resize:vertical; padding:12px; border-radius:12px;
      border:1px solid rgba(233,236,255,.16); background:rgba(0,0,0,.22); color:var(--text);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      line-height:1.35;
    }
    input[type="text"]{
      width:min(520px,100%); padding:10px 12px; border-radius:12px;
      border:1px solid rgba(233,236,255,.16); background:rgba(0,0,0,.22); color:var(--text);
    }
    footer{margin-top:14px; padding:14px 18px; color:var(--faint); font-size:13px}
    .sr{position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden}

.chatFeed{
  border:1px solid rgba(233,236,255,.12);
  background:rgba(0,0,0,.18);
  border-radius:12px;
  padding:12px;
  min-height:220px;
  overflow:auto;
  display:flex;
  flex-direction:column;
  gap:10px;
}

/* Messages card layout stacks and transcript stretches */
#messagesCard{
  display:flex;
  flex-direction:column;
}
#chatFeed{
  flex:1;
  min-height:280px; /* normal mode baseline */
}

/* Session active makes transcript taller */
body.sessionActive .chatFeed{
  min-height:52vh;
  max-height:52vh;
}

/* Chat expand / zen mode */
body.zenMode{
  overflow:hidden;
}
body.zenMode #messagesCard{
  position:fixed;
  inset:12px;
  z-index:9999;
  margin:0;
  max-width:none;
  height:calc(100vh - 24px);
}
body.zenMode details,
body.zenMode #messagesCard p.faint{
  display:none;
}
/* Required for flex children */
body.zenMode #chatFeed{
  min-height:0;
  height:auto;
}


.bubble{
  max-width:80%;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(233,236,255,.12);
  background:rgba(255,255,255,.05);
  white-space:pre-wrap;
  word-break:break-word;
}

.bubble.you{
  align-self:flex-end;
  border-color:rgba(71,230,177,.30);
  background:rgba(71,230,177,.10);
}

.bubble.sys{
  align-self:center;
  max-width:90%;
  border-color:rgba(255,204,102,.35);
  background:rgba(255,204,102,.10);
}

.bubble.peer{
  align-self:flex-start;
  border-color:rgba(120,166,255,.30);
  background:rgba(120,166,255,.10);
}

.metaLine{
  font-size:12px;
  color:var(--faint);
  margin-bottom:6px;
}

  /* --- sender accents (session-only) --- */
.bubble.peer{
  border-left:4px solid var(--who, rgba(255,255,255,.15));
  padding-left:10px;
}

.metaLine{
  display:flex;
  align-items:center;
  gap:8px;
}

.metaLine::before{
  content:"";
  width:8px;
  height:8px;
  border-radius:999px;
  background: var(--who, rgba(255,255,255,.25));
  flex:0 0 auto;
}

/* --- reply bar --- */
.replyBar{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  margin:10px 0 8px;
  padding:8px 10px;
  border:1px solid rgba(255,255,255,.10);
  border-radius:12px;
  background:rgba(255,255,255,.04);
}

/* --- expand button --- */
    #fsBtn{ min-width:92px; white-space:nowrap; }
.messageRow {
  display: flex;
  gap: 8px;
  align-items: center;
}

.messageRow input {
  flex: 1 1 auto;
  min-width: 0;
}


/* Join request queue (host-only, session-only) */
.requests{margin:10px 0 12px;padding:10px;border:1px solid rgba(255,255,255,.08);border-radius:12px;background:rgba(10,14,30,.35)}
.reqHead{display:flex;align-items:flex-start;justify-content:space-between;gap:12px;margin-bottom:8px}
.reqTitle{font-weight:700}
.reqHint{color:var(--muted);font-size:12px;line-height:1.35;max-width:520px}
.reqList{display:flex;flex-direction:column;gap:8px}
.reqRow{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:8px;border-radius:10px;background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.06)}
.reqName{display:flex;align-items:center;gap:8px;font-weight:600}
.reqDot{width:8px;height:8px;border-radius:999px;background:var(--accent-2);box-shadow:0 0 0 3px rgba(8,217,214,.15)}
.reqBtns{display:flex;gap:8px}


/* muted bar */
#mutedList{display:flex;flex-wrap:wrap;gap:8px}
.mutedChip{
  display:inline-flex;align-items:center;gap:8px;
  padding:6px 10px;border-radius:999px;
  border:1px solid rgba(233,236,255,.14);
  background:rgba(0,0,0,.16);
}
.mutedChip .name{font-weight:700}
.mutedChip .time{color:var(--faint);font-size:12px}
.mutedChip button{padding:4px 8px;border-radius:999px}
</style>
</head>

<body>
  <div class="wrap">
    <header>
      <div>
        <h1>HereNow — Chat</h1>
        <p>
          This page stays idle until you explicitly opt in for this session.
          No background activity. Close tab = chat off.
        </p>
      </div>
      <div class="row">
        <a class="btn" href="/herenow">Back to contract</a>
      </div>
    </header>

    <main class="grid">
<section id="step1">
        <h2 style="margin:0 0 10px; font-size:16px">Step 1 — Room setup</h2>
        <p class="muted" style="margin:0 0 10px">
          Choose a handle and (optionally) enable host approval. Nothing connects until you start the session.
        </p>

        <label class="faint" for="displayNameInput" style="display:block; margin:12px 0 6px;">
          Chat handle (no real names)
        </label>
        <input
          id="displayNameInput"
          type="text"
          autocomplete="off"
          spellcheck="false"
          autocapitalize="none"
          maxlength="24"
          placeholder="@3HPM"
        />
        <p class="faint" style="margin:6px 0 0;">
          Not saved. Session-only.
        </p>

        <div class="box" style="margin-top:14px">
          <div style="font-weight:800; margin-bottom:6px">Join approval</div>
          <div class="muted" style="margin-bottom:10px">
            If enabled, new joiners must be approved by the host before they can send/receive chat. No passphrases.
          </div>
          <div class="row" style="align-items:center">
            <label class="faint" for="approvalToggle" style="display:flex; align-items:center; gap:10px; font-weight:800">
              <input id="approvalToggle" type="checkbox" />
              Require host approval
            </label>
            <span class="faint" id="approvalHostOnlyHint" style="display:none">Host-only setting.</span>
          </div>

          <div class="row" style="margin-top:10px; align-items:center">
            <label class="faint" for="cooldownSelect" style="min-width:160px">Deny/Kick cooldown</label>
            <select id="cooldownSelect" class="btn" style="padding:8px 12px">
              <option value="5">5 minutes</option>
              <option value="15" selected>15 minutes</option>
              <option value="60">60 minutes</option>
            </select>
            <span class="faint">Applies to Deny and Kick. Session-only (in-memory).</span>
          </div>
        </div>

        <h3 style="margin:16px 0 10px; font-size:14px">Room link</h3>
        <p class="muted" style="margin:0 0 10px">
          Generated when you start the session.
        </p>

        <div class="row">
          <input id="roomInput" type="text" value="(not yet created)" readonly />
          <button class="btn" id="copyBtn" type="button" disabled>Copy link</button>
          <span id="copyToast" class="toast good" style="display:none; margin-left:8px;">Copied</span>
        </div>

        <p class="" style="margin:10px 0 0">
          Rule: no discovery. Rooms exist only as URLs you explicitly share.
        </p>
      </section>

<section aria-labelledby="statusTitle">
        <h2 id="statusTitle" class="sr">Session status</h2>
        <div class="row" style="justify-content:space-between">
          <div class="row">
            <span class="pill" id="statusPill"><span class="dot" id="statusDot"></span><span id="statusText">Not started</span></span>
            <span class="pill"><span class="faint">Networking:</span> <span id="netText">OFF</span></span>
          </div>
          <div class="row">
            <button class="btn primary" id="enableBtn" type="button">Start session</button>
          <button class="btn danger" id="disableBtn" type="button" disabled>
  End session
</button>

          </div>
        </div>

        <div style="margin-top:12px" class="box">
          <div class="muted">
            This tab stays off until you start the session.
          </div>
        </div>
      </section>

      
      <section class="card" id="messagesCard">

  <h2 style="margin:0 0 10px; font-size:16px">Messages</h2>
  <p class="muted" style="margin:0 0 10px">
    Invite-only chat. Messages go directly between people in the room.
  </p>

  <!-- User-friendly chat transcript -->
              <div class="reqHint">Host-only. Approve to let them chat; deny to block for the selected cooldown.</div>
            </div>
            <div id="joinReqList" class="reqList"></div>
          </div>

  <div id="chatFeed" class="chatFeed" aria-label="Chat transcript"></div>

  

  <div id="mutedBar" class="box" style="margin-top:10px; display:none;">
    <div style="font-weight:800; margin-bottom:6px">Muted (this tab)</div>
    <div id="mutedList" class="faint"></div>
  </div>
<div id="replyBar" class="replyBar" style="display:none;">
  <span id="replyText" class="faint"></span>
  <div class="row" style="margin-left:auto; gap:8px">
    <button id="muteBtn" class="btn" type="button" style="padding:6px 10px;">Mute</button>
    <button id="kickBtn" class="btn danger" type="button" style="padding:6px 10px; display:none;">Kick</button>
    <button id="replyClear" class="btn" type="button" style="padding:6px 10px;">×</button>
  </div>
</div>
<div class="messageRow">
  <input id="msgInput" type="text" placeholder="Type a message" />
  <button id="sendBtn" class="btn">Send</button>
  <button id="fsBtn" class="btn">Expand</button>
</div>


  <details style="margin-top:12px">
    <summary class="faint">Connection details</summary>
    <textarea id="log" readonly aria-label="Connection details">(idle)
- no connections
- no signaling
- no WebRTC
</textarea>
  </details>

  <p class="faint" style="margin:10px 0 0">
    Reminder: Users can screenshot. Ephemeral is not the same as “unrecordable.”
  </p>
</section>


      <footer>
        If a feature requires background activity, persistence, or discovery, it fails the vibe check and gets vetoed.
      </footer>
    </main>
  </div>

<script type="module">
(() => {
  // Consent-first invariant:
  // - No networking until user clicks Start session
  // - Close tab = disconnect
  // - No polling, no timers except local UI timers for mute countdown display

  // ---------- helpers ----------
  const $ = (id) => document.getElementById(id);

  function base64url(bytes) {
    let bin = "";
    for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
    return btoa(bin).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
  }

  function generateRoomId() {
    const bytes = new Uint8Array(16);
    crypto.getRandomValues(bytes);
    return "hn_" + base64url(bytes);
  }

  function readRoomIdFromUrl() {
    const url = new URL(window.location.href);
    const r = url.searchParams.get("r");
    if (!r) return null;
    if (!/^hn_[A-Za-z0-9_-]{16,80}$/.test(r)) return null;
    return r;
  }

  function setRoomIdInUrl(roomId) {
    const url = new URL(window.location.href);
    url.searchParams.set("r", roomId);
    history.replaceState(null, "", url.toString());
  }

  function currentShareUrl(roomId) {
    const url = new URL(window.location.href);
    url.searchParams.set("r", roomId);
    return url.toString();
  }

  function generatePeerId() {
    const bytes = new Uint8Array(9);
    crypto.getRandomValues(bytes);
    return "p_" + base64url(bytes);
  }

  async function copyText(text) {
    if (navigator.clipboard && window.isSecureContext) {
      await navigator.clipboard.writeText(text);
      return;
    }
    const ta = document.createElement("textarea");
    ta.value = text;
    ta.setAttribute("readonly", "");
    ta.style.position = "absolute";
    ta.style.left = "-9999px";
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    document.body.removeChild(ta);
  }

  function clampMinutes(v) {
    const n = parseInt(String(v || ""), 10);
    if (!Number.isFinite(n)) return 15;
    return Math.max(1, Math.min(120, n));
  }

  // ---------- UI ----------
  const ui = {
    statusDot: $("statusDot"),
    statusText: $("statusText"),
    netText: $("netText"),
    enableBtn: $("enableBtn"),
    disableBtn: $("disableBtn"),

    roomInput: $("roomInput"),
    copyBtn: $("copyBtn"),
    copyToast: $("copyToast"),
    displayNameInput: $("displayNameInput"),
    cooldownSelect: $("cooldownSelect"),

    log: $("log"),
    msgInput: $("msgInput"),
    sendBtn: $("sendBtn"),
    chatFeed: $("chatFeed"),
    mutedBar: $("mutedBar"),
    mutedList: $("mutedList"),
    fsBtn: $("fsBtn"),

    replyBar: $("replyBar"),
    replyText: $("replyText"),
    replyClear: $("replyClear"),
    muteBtn: $("muteBtn"),
    kickBtn: $("kickBtn"),
  };

  // ---------- state ----------
  const state = {
    enabled: false,
    roomUrl: null,
    roomId: null,
    peerId: null,

    ws: null,

    // Roles
    isHost: false,   // creator tab (the one that generated the room id)
    hostId: null,    // host peerId once connected

    // Policy knobs (session-only)
    controlMinutes: 15, // kick cooldown, and default mute duration

    // Deny/kick (host only): peerId -> epoch ms
    denyUntilByPeer: new Map(),

    // Local mute (per-tab): peerId -> epoch ms
    mutedUntilByPeer: new Map(),

    // peers: peerId -> { pc, dc, makingOffer, madeOffer }
    peers: new Map(),

    // track peers we've seen (prevents hello loops)
    seenPeers: new Set(),

    // peer labels (session-only): peerId -> handle
    peerNames: new Map(),

    rtcConfig: {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" },
      ],
    },
  };

  // ---------- per-sender color helpers ----------
  function hashHue(str) {
    let h = 0;
    const s = String(str || "");
    for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) >>> 0;
    return h % 360;
  }
  function peerColor(key) {
    const hue = hashHue(key || "peer");
    return `hsl(${hue} 65% 60%)`;
  }

  // ---------- reply + message helpers ----------
  let replyTo = null; // { peerId, name, text }

  function getDisplayName() {
    const el = ui.displayNameInput;
    let raw = (el?.value || "").trim();
    raw = raw.replace(/\s+/g, "");
    raw = raw.replace(/[^@a-zA-Z0-9_.]/g, "");
    raw = raw.slice(0, 24);
    return raw || null;
  }

  function setReplyTo(obj) {
    replyTo = obj;
    if (!obj) {
      ui.replyBar.style.display = "none";
      ui.replyText.textContent = "";
      return;
    }
    ui.replyBar.style.display = "flex";
    const snippet = String(obj.text || "").trim().slice(0, 80);
    ui.replyText.textContent = `Replying to ${obj.name}: “${snippet}${snippet.length >= 80 ? "…" : ""}”`;

    const canTarget = !!replyTo && !!replyTo.peerId && replyTo.peerId !== state.peerId;
    ui.muteBtn.style.display = canTarget ? "" : "none";
    ui.kickBtn.style.display = (canTarget && state.isHost) ? "" : "none";
    ui.muteBtn.textContent = canTarget && isMuted(replyTo.peerId) ? "Unmute" : "Mute";
  }

  function makeMsgId() {
    try { return crypto.randomUUID(); } catch {}
    return String(Date.now()) + "_" + Math.random().toString(16).slice(2);
  }

  function addBubble(who, text, peerId, reply) {
    const wrap = document.createElement("div");
    wrap.className = `bubble ${who}`;

    const meta = document.createElement("div");
    meta.className = "metaLine";

    if (who === "you") {
      const me = getDisplayName();
      meta.textContent = me ? `You (${me})` : "You";
    } else if (who === "sys") {
      meta.textContent = "System";
    } else {
      const label =
        (peerId && state.peerNames.get(peerId)) ? state.peerNames.get(peerId)
        : (peerId || "Peer");
      meta.textContent = label;

      const colorKey = (peerId && state.peerNames.get(peerId)) ? state.peerNames.get(peerId) : peerId;
      wrap.style.setProperty("--who", peerColor(colorKey || label));
    }

    const body = document.createElement("div");
    body.textContent = text;

    wrap.appendChild(meta);

    if (reply && reply.name && reply.text) {
      const q = document.createElement("div");
      q.className = "faint";
      q.style.margin = "6px 0 8px";
      const snippet = String(reply.text).trim().slice(0, 80);
      q.textContent = `↪ replying to ${reply.name}: “${snippet}${snippet.length >= 80 ? "…" : ""}”`;
      wrap.appendChild(q);
    }

    wrap.appendChild(body);

    wrap.addEventListener("click", () => {
      if (who !== "peer") return;
      const name = state.peerNames.get(peerId) || peerId || "Peer";
      setReplyTo({ peerId, name, text });
      ui.msgInput?.focus();
    });

    ui.chatFeed.appendChild(wrap);
    ui.chatFeed.scrollTop = ui.chatFeed.scrollHeight;
  }

  function showSystemNote(text) {
    addBubble("sys", String(text || ""), "system", null);
  }

  function appendLog(line) {
    const t = new Date().toISOString().replace("T", " ").replace("Z", " UTC");
    ui.log.value += `\n[${t}] ${line}`;
    ui.log.scrollTop = ui.log.scrollHeight;
  }

  function setTopStatus(lines) {
    const parts = ui.log.value.split("\n");
    const rest = parts.slice(4);
    ui.log.value = lines.join("\n") + "\n" + rest.join("\n");
  }

  // ---------- session UI ----------
  function setRoomUi(roomId) {
    state.roomId = roomId;
    state.roomUrl = currentShareUrl(roomId);
    ui.roomInput.value = state.roomUrl;

    if (state.isHost) {
      ui.copyBtn.disabled = !(state.enabled && state.roomUrl);
      ui.copyBtn.style.display = "";
    } else {
      ui.copyBtn.disabled = true;
      ui.copyBtn.style.display = "none";
    }
  }

  function resetRoomUi() {
    state.roomId = null;
    state.roomUrl = null;
    ui.roomInput.value = "(not yet created)";
    ui.copyBtn.disabled = true;
  }

  function setStatus(enabled) {
    state.enabled = !!enabled;

    ui.statusDot.classList.toggle("good", state.enabled);
    ui.statusDot.classList.toggle("bad", false);

    ui.statusText.textContent = state.enabled ? "Session live" : "Not started";
    ui.enableBtn.disabled = state.enabled;
    ui.disableBtn.disabled = !state.enabled;

    ui.copyBtn.disabled = !(state.enabled && state.roomUrl);

    ui.netText.textContent = state.enabled ? (state.ws ? "SIGNALING (connecting…)" : "SIGNALING (not connected)") : "OFF";
  }

  function anyOpenDataChannels() {
    return Array.from(state.peers.values()).some((p) => p.dc && p.dc.readyState === "open");
  }

  function updateChatInputState() {
    const anyOpen = anyOpenDataChannels();
    const canChat = state.enabled && anyOpen;

    ui.msgInput.disabled = !canChat;
    ui.sendBtn.disabled = !canChat;

    if (!state.enabled) {
      ui.msgInput.placeholder = "Chat is off (start session first)";
      return;
    }
    if (!anyOpen) {
      ui.msgInput.placeholder = "Waiting for someone to join";
      return;
    }
    ui.msgInput.placeholder = "Type a message";
  }

  // ---------- kick / deny / mute ----------
  function denySeconds() {
    return Math.max(60, clampMinutes(state.controlMinutes) * 60);
  }

  function isDenied(peerId) {
    const until = state.denyUntilByPeer.get(peerId);
    return !!until && until > Date.now();
  }

  function applyDeny(peerId, reason) {
    const until = Date.now() + denySeconds() * 1000;
    state.denyUntilByPeer.set(peerId, until);
    appendLog(`Denylist: ${peerId} until ${new Date(until).toISOString()} (${reason || "deny"})`);
  }

  function isMuted(peerId) {
    const until = state.mutedUntilByPeer.get(peerId);
    return !!until && until > Date.now();
  }

  function applyMute(peerId, minutes) {
    const until = Date.now() + clampMinutes(minutes) * 60 * 1000;
    state.mutedUntilByPeer.set(peerId, until);
  }

  function clearMute(peerId) {
    state.mutedUntilByPeer.delete(peerId);
  }

  function renderMutedBar() {
    if (!ui.mutedBar || !ui.mutedList) return;

    // Drop expired entries
    const now = Date.now();
    for (const [pid, until] of state.mutedUntilByPeer.entries()) {
      if (!until || until <= now) state.mutedUntilByPeer.delete(pid);
    }

    if (state.mutedUntilByPeer.size === 0) {
      ui.mutedBar.style.display = "none";
      ui.mutedList.innerHTML = "";
      return;
    }

    ui.mutedBar.style.display = "";
    const chips = [];
    for (const [pid, until] of state.mutedUntilByPeer.entries()) {
      const name = state.peerNames.get(pid) || pid;
      const minsLeft = Math.max(0, Math.ceil((until - now) / 60000));
      chips.push(
        `<span class="mutedChip" data-pid="${pid}">
          <span class="name">${escapeHtml(name)}</span>
          <span class="time">${minsLeft}m left</span>
          <button class="btn" type="button" data-unmute="${pid}">Unmute</button>
        </span>`
      );
    }
    ui.mutedList.innerHTML = chips.join("");

    ui.mutedList.querySelectorAll("button[data-unmute]").forEach((b) => {
      b.addEventListener("click", () => {
        const pid = b.getAttribute("data-unmute");
        if (!pid) return;
        clearMute(pid);
        showSystemNote(`Unmuted ${state.peerNames.get(pid) || pid}.`);
        if (replyTo && replyTo.peerId === pid) setReplyTo(replyTo);
        renderMutedBar();
      });
    });
  }


  // ---------- signaling ----------
  function wsUrlForRoom(roomId) {
    const base = "wss://herenow-signal.the-geek.workers.dev/signal/";
    return base + encodeURIComponent(roomId);
  }

  function sendSignal(msg) {
    if (!state.ws || state.ws.readyState !== WebSocket.OPEN) return;
    try { state.ws.send(JSON.stringify(msg)); } catch { appendLog("Signaling: send failed"); }
  }

  function mkMsg(t, to, payload) {
    return { t, room: state.roomId, from: state.peerId, to, payload: payload ?? null, ts: Date.now() };
  }

  function disconnectAll(reason = "disconnect") {
    for (const [, p] of state.peers.entries()) {
      try { p.dc && p.dc.close(); } catch {}
      try { p.pc && p.pc.close(); } catch {}
    }
    state.peers.clear();

    if (state.ws) {
      try { appendLog(`Signaling: closing (${reason})`); state.ws.close(1000, reason); } catch {}
      state.ws = null;
    }

    if (state.enabled) ui.netText.textContent = "SIGNALING (not connected)";
  }

  function leaveSession(reason = "leave") {
    disconnectAll(reason);

    setStatus(false);

    ui.enableBtn.disabled = false;
    ui.enableBtn.textContent = "Start session";

    document.body.classList.remove("sessionActive");
    state.peerId = null;
    state.seenPeers.clear();
    state.peerNames.clear();
    state.denyUntilByPeer.clear();
    state.mutedUntilByPeer.clear();
    setReplyTo(null);
    renderMutedBar();

    ui.log.value = "(idle)\n- no connections\n- no signaling\n- no WebRTC\n";
    ui.chatFeed.innerHTML = "";
    updateChatInputState();
  }

  function connectSignaling(roomId) {
    if (!state.enabled) return;

    const url = wsUrlForRoom(roomId);
    appendLog(`Signaling: connecting to ${url}`);

    const ws = new WebSocket(url);
    state.ws = ws;
    ui.netText.textContent = "SIGNALING (connecting…)";

    ws.addEventListener("open", () => {
      appendLog(`Signaling: connected as ${state.peerId}`);
      ui.netText.textContent = "SIGNALING (connected)";

      setTopStatus([
        "(enabled)",
        "- connections: 0",
        "- signaling: connected",
        "- WebRTC: negotiating"
      ]);

      sendSignal(mkMsg("hello", "*", { v: 1 }));
    });

    ws.addEventListener("message", async (ev) => {
      let msg;
      try { msg = JSON.parse(typeof ev.data === "string" ? ev.data : ""); } catch { return; }

      if (!msg || msg.room !== state.roomId) return;
      if (msg.from === state.peerId) return;
      if (msg.to && msg.to !== "*" && msg.to !== state.peerId) return;

      try { await handleSignal(msg); } catch { appendLog(`Signaling: handler error (${msg.t})`); }
    });

    ws.addEventListener("close", (ev) => {
      appendLog(`Signaling: closed (code ${ev.code})`);
      state.ws = null;
      if (state.enabled) ui.netText.textContent = "SIGNALING (not connected)";
    });

    ws.addEventListener("error", () => appendLog("Signaling: error"));
  }

  window.addEventListener("pagehide", () => leaveSession("pagehide"));

  // ---------- WebRTC peer management ----------
  function shouldBeOfferer(remotePeerId) {
    return state.peerId < remotePeerId;
  }

  function ensurePeer(remotePeerId) {
    let peer = state.peers.get(remotePeerId);
    if (peer) return peer;

    const pc = new RTCPeerConnection(state.rtcConfig);
    peer = { pc, dc: null, makingOffer: false, madeOffer: false };
    state.peers.set(remotePeerId, peer);

    pc.addEventListener("icecandidate", (ev) => {
      if (!ev.candidate) return;
      sendSignal(mkMsg("ice", remotePeerId, { candidate: ev.candidate }));
    });

    pc.addEventListener("connectionstatechange", () => {
      appendLog(`RTC: ${remotePeerId} pc=${pc.connectionState}`);

      const connectedCount = [...state.peers.values()]
        .filter(p => p.pc && p.pc.connectionState === "connected").length;

      setTopStatus([
        "(enabled)",
        `- connections: ${connectedCount}`,
        "- signaling: connected",
        `- WebRTC: ${connectedCount ? "connected" : "not connected"}`
      ]);
    });

    pc.addEventListener("datachannel", (ev) => {
      peer.dc = ev.channel;
      wireDataChannel(remotePeerId, peer.dc);
    });

    return peer;
  }

  function sendData(peerId, obj) {
    const p = state.peers.get(peerId);
    if (!p || !p.dc || p.dc.readyState !== "open") return false;
    try { p.dc.send(JSON.stringify(obj)); return true; } catch { return false; }
  }

  function broadcastData(obj) {
    const payload = JSON.stringify(obj);
    for (const [, p] of state.peers.entries()) {
      if (p.dc && p.dc.readyState === "open") {
        try { p.dc.send(payload); } catch {}
      }
    }
  }

  function closePeer(peerId, reason) {
    const p = state.peers.get(peerId);
    if (!p) return;

    try { p.dc && p.dc.close(); } catch {}
    try { p.pc && p.pc.close(); } catch {}

    state.peers.delete(peerId);
    appendLog(`Peer closed ${peerId}${reason ? " (" + reason + ")" : ""}`);
    updateChatInputState();
    if (replyTo && replyTo.peerId === peerId) setReplyTo(null);
  }

  function wireDataChannel(remotePeerId, dc) {
    const peer = state.peers.get(remotePeerId);
    if (!peer) return;

    peer.dc = dc;

    dc.onopen = () => {
      appendLog(`DataChannel open with ${remotePeerId}`);

      sendData(remotePeerId, { t: "hello", name: getDisplayName() || "" });

      if (state.isHost) {
        state.hostId = state.peerId;
        sendData(remotePeerId, { t: "host_announce", hostId: state.peerId, controlMinutes: state.controlMinutes });
      }

      updateChatInputState();
    };

    dc.onclose = () => {
      appendLog(`DataChannel closed with ${remotePeerId}`);
      updateChatInputState();
    };

    dc.onmessage = (ev) => {
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }
      if (!msg || typeof msg.t !== "string") return;

      if (msg.t === "hello") {
        if (msg.name && typeof msg.name === "string") {
          state.peerNames.set(remotePeerId, msg.name.slice(0, 24));
        }
        return;
      }

      if (msg.t === "host_announce") {
        if (msg.hostId && typeof msg.hostId === "string") {
          if (!state.hostId) state.hostId = msg.hostId;
        }
        if (Number.isFinite(msg.controlMinutes)) {
          state.controlMinutes = clampMinutes(msg.controlMinutes);
        }
        updateChatInputState();
        return;
      }

      if (msg.t === "kick") {
        if (state.hostId && remotePeerId !== state.hostId) return;

        const mins = clampMinutes(msg.mins || state.controlMinutes || 15);
        showSystemNote(`Kicked by host. Try again in ${mins} minutes.`);
        closePeer(remotePeerId, "kicked");
        return;
      }

      if (msg.t === "chat") {
        if (isMuted(remotePeerId)) return;
        addBubble("peer", msg.text || "", remotePeerId, msg.replyTo || null);
        renderMutedBar();
        return;
      }
    };
  }

  async function createOfferTo(remotePeerId) {
    const peer = ensurePeer(remotePeerId);
    if (peer.makingOffer || peer.madeOffer) return;
    peer.makingOffer = true;

    try {
      if (!peer.dc) {
        peer.dc = peer.pc.createDataChannel("chat");
        wireDataChannel(remotePeerId, peer.dc);
      }

      const offer = await peer.pc.createOffer();
      await peer.pc.setLocalDescription(offer);

      sendSignal(mkMsg("offer", remotePeerId, { sdp: peer.pc.localDescription }));
      appendLog(`RTC: sent offer to ${remotePeerId}`);
      peer.madeOffer = true;
    } finally {
      peer.makingOffer = false;
    }
  }

  async function handleSignal(msg) {
    const remotePeerId = msg.from;

    if (msg.t === "hello") {
      const firstTime = !state.seenPeers.has(remotePeerId);
      if (firstTime) state.seenPeers.add(remotePeerId);

      if (firstTime) {
        appendLog(`Signaling: hello from ${remotePeerId}`);
        sendSignal(mkMsg("hello", remotePeerId, { v: 1, ack: true }));
        sendSignal(mkMsg("hello", "*", { v: 1, bounce: true }));
      }

      if (state.isHost && isDenied(remotePeerId)) {
        // We'll still negotiate, but host will kick quickly once the DC opens if needed.
        appendLog(`Peer ${remotePeerId} is currently denylisted (will be kicked).`);
      }

      if (shouldBeOfferer(remotePeerId)) {
        await createOfferTo(remotePeerId);
      }
      return;
    }

    if (msg.t === "offer") {
      const peer = ensurePeer(remotePeerId);
      await peer.pc.setRemoteDescription(new RTCSessionDescription(msg.payload.sdp));
      const answer = await peer.pc.createAnswer();
      await peer.pc.setLocalDescription(answer);

      sendSignal(mkMsg("answer", remotePeerId, { sdp: peer.pc.localDescription }));
      appendLog(`RTC: recv offer + sent answer to ${remotePeerId}`);
      return;
    }

    if (msg.t === "answer") {
      const peer = ensurePeer(remotePeerId);
      await peer.pc.setRemoteDescription(new RTCSessionDescription(msg.payload.sdp));
      appendLog(`RTC: recv answer from ${remotePeerId}`);
      return;
    }

    if (msg.t === "ice") {
      const peer = ensurePeer(remotePeerId);
      if (msg.payload && msg.payload.candidate) {
        try { await peer.pc.addIceCandidate(new RTCIceCandidate(msg.payload.candidate)); } catch {}
      }
      return;
    }
  }

  // ---------- chat ----------
  function broadcastChat(text) {
    const payload = JSON.stringify({
      t: "chat",
      id: makeMsgId(),
      text,
      displayName: getDisplayName(),
      replyTo: replyTo ? { name: replyTo.name, text: String(replyTo.text || "").trim().slice(0, 80) } : null,
      ts: Date.now(),
    });

    for (const [, p] of state.peers.entries()) {
      if (p.dc && p.dc.readyState === "open") {
        try { p.dc.send(payload); } catch {}
      }
    }
  }

  // ---------- controls ----------
  ui.replyClear.addEventListener("click", () => setReplyTo(null));

  ui.muteBtn.addEventListener("click", () => {
    if (!replyTo) return;
    const pid = replyTo.peerId;
    if (!pid || pid === state.peerId) return;

    const mins = clampMinutes(state.controlMinutes || 15);

    if (isMuted(pid)) {
      clearMute(pid);
      showSystemNote(`Unmuted ${replyTo.name}.`);
    } else {
      applyMute(pid, mins);
      showSystemNote(`Muted ${replyTo.name} for ${mins} minutes.`);
    }
    setReplyTo(replyTo);
    renderMutedBar();
  });

  ui.kickBtn.addEventListener("click", () => {
    if (!replyTo || !state.isHost) return;
    const pid = replyTo.peerId;
    if (!pid || pid === state.peerId) return;

    const mins = clampMinutes(state.controlMinutes || 15);
    applyDeny(pid, "host kicked");

    sendData(pid, { t: "kick", mins });
    showSystemNote(`Kicked ${replyTo.name} (${mins}m).`);

    closePeer(pid, "host kicked");
    broadcastData({ t: "peer_kicked", peerId: pid, mins, by: state.peerId });

    setReplyTo(null);
  });

  // Start session
  ui.enableBtn.addEventListener("click", () => {
    setStatus(true);
    document.body.classList.add("sessionActive");
    ui.enableBtn.textContent = "Enabled";

    const existingRoomId = readRoomIdFromUrl();
    state.isHost = !existingRoomId;

    state.controlMinutes = clampMinutes(ui.cooldownSelect?.value || 15);

    let roomId = existingRoomId;
    if (!roomId) {
      roomId = generateRoomId();
      setRoomIdInUrl(roomId);
    }

    setRoomUi(roomId);

    state.peerNames.clear();
    state.peerId = generatePeerId();

    ui.log.value = "(enabled)\n- connections: 0\n- signaling: connecting\n- WebRTC: off";
    ui.chatFeed.innerHTML = "";

    appendLog("Consent granted for this tab. Room prepared locally.");
    updateChatInputState();
    connectSignaling(roomId);
  });

  ui.disableBtn.addEventListener("click", () => leaveSession("disabled"));

  ui.copyBtn.addEventListener("click", async () => {
    if (!state.enabled || !state.roomUrl) return;
    try {
      await copyText(state.roomUrl);
      appendLog("Copied room link to clipboard.");

      ui.copyToast.textContent = "Copied ✅";
      ui.copyToast.classList.remove("bad");
      ui.copyToast.classList.add("good");
      ui.copyToast.style.display = "inline-block";
      setTimeout(() => { ui.copyToast.style.display = "none"; }, 1200);
    } catch {
      appendLog("Copy failed (clipboard permissions?). You can manually copy the URL.");

      ui.copyToast.textContent = "Copy failed";
      ui.copyToast.classList.remove("good");
      ui.copyToast.classList.add("bad");
      ui.copyToast.style.display = "inline-block";
      setTimeout(() => { ui.copyToast.style.display = "none"; }, 1800);
    }
  });

  // Expand / zen mode
  function setFsLabel() {
    const isFs = !!document.fullscreenElement;
    const isZen = document.body.classList.contains("zenMode");
    if (ui.fsBtn) ui.fsBtn.textContent = (isFs || isZen) ? "Exit Full Screen" : "Expand Chat Window";
  }

  async function toggleExpand() {
    if (document.fullscreenElement) {
      await document.exitFullscreen().catch(() => {});
      setFsLabel();
      return;
    }
    if (document.body.classList.contains("zenMode")) {
      document.body.classList.remove("zenMode");
      setFsLabel();
      return;
    }

    const target = document.getElementById("messagesCard") || document.documentElement;
    try { await target.requestFullscreen(); }
    catch { document.body.classList.add("zenMode"); }
    setFsLabel();
  }

  ui.fsBtn?.addEventListener("click", toggleExpand);
  document.addEventListener("fullscreenchange", setFsLabel);
  setFsLabel();

  // Send
  ui.sendBtn.addEventListener("click", () => {
    const msg = ui.msgInput.value.trim();
    if (!msg) return;

    ui.msgInput.value = "";
    appendLog(`you: ${msg}`);
    addBubble("you", msg, state.peerId, replyTo ? { name: replyTo.name, text: String(replyTo.text || "").trim().slice(0, 80) } : null);
    broadcastChat(msg);
    setReplyTo(null);
  });

  ui.msgInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") ui.sendBtn.click();
  });

  // Init inert
  setStatus(false);
  updateChatInputState();
  renderMutedBar();

  const initialRoomId = readRoomIdFromUrl();
  state.isHost = !initialRoomId;
  state.controlMinutes = clampMinutes(ui.cooldownSelect?.value || 15);

  if (initialRoomId) setRoomUi(initialRoomId);
  else resetRoomUi();

  ui.cooldownSelect?.addEventListener("change", () => {
    state.controlMinutes = clampMinutes(ui.cooldownSelect.value || 15);
  });

  // ---- optional extension bridge ----
  window.addEventListener("message", (ev) => {
    const d = ev && ev.data;
    if (!d || d.source !== "herenow-extension") return;
    if (d.type === "enable-session") {
      appendLog("Extension consent received for this tab.");
      if (ui.enableBtn && !state.enabled) ui.enableBtn.click();
    }
  });
})();
</script>



</body>
</html>
